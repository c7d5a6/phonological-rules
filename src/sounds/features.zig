const std = @import("std");

pub const Feature = enum(u5) {
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////// MANNER FEATURES ///////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // +-------------+--------+---------+--------+-------------+
    // |    Vowels   | Glides | Liquids | Nasals |  Obstruents |
    // +=============+========+=========+========+=============+
    // | [+syllabic] |               [−syllabic]               |
    // +-------------+--------+--------------------------------+
    // |    [−consonantal]    |         [+consonantal]         |
    // +----------------------+---------+----------------------+
    // |         [+approximant]         |    [−approximant]    |
    // +--------------------------------+--------+-------------+
    // |               [+sonorant]               | [−sonorant] |
    // +-----------------------------------------+-------------+
    syllabic, // syllabic ˌ • ◌̩ // non syllabic ◌͏̯
    consonantal,
    approximant,
    sonorant,
    // +--------------------+------------+---------------+
    // |        Stops       | Affricates |   Fricatives  |
    // +====================+============+===============+
    // |          [−continuant]          | [+continuant] |
    // +--------------------+------------+---------------+
    // | [−delayed release] |     [+delayed release]     |
    // +--------------------+----------------------------+
    continuant,
    delayed_release,
    //
    // ////////////// Trills and taps ///////////////////
    //
    trill,
    tap,
    flap,
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////// VOWEL FEATURES  ///////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // +----------+---------+---------+
    // |   Front  | Central |   Back  |
    // +==========+=========+=========+
    // |       [−back]      | [+back] |
    // +----------+---------+---------+
    // | [+front] |      [−front]     |
    // +----------+-------------------+
    back,
    front,
    // upper high [+high] [−low] [+tense]
    // lower high [+high] [−low] [-tense]
    // upper mid  [-high] [−low] [+tense]
    // lower mid  [-high] [−low] [-tense]
    // low        [-high] [+low]
    high,
    low,
    tense,
    // ////////////// Rounding ///////////////////
    round,
    // +-----------------------+---------------------+---------------------+---------------------+
    // |                       |   [+front, −back]   |   [−front, −back]   |   [−front, +back]   |
    // |                       +----------+----------+----------+----------+----------+----------+
    // |                       | [−round] | [+round] | [−round] | [+round] | [−round] | [+round] |
    // +=======================+==========+==========+==========+==========+==========+==========+
    // | [+high, −low, +tense] |     i    |     y    |     ɨ    |     ʉ    |     ɯ    |     u    |
    // +-----------------------+----------+----------+----------+----------+----------+----------+
    // | [+high, −low, −tense] |     ɪ    |     ʏ    |          |          |          |     ʊ    |
    // +-----------------------+----------+----------+----------+----------+----------+----------+
    // | [−high, −low, +tense] |     e    |     ø    |     ɘ    |     ɵ    |     ɤ    |     o    |
    // +-----------------------+----------+----------+----------+----------+----------+----------+
    // | [−high, −low, −tense] |     ɛ    |     œ    |     ɜ    |     ɞ    |     ʌ    |     ɔ    |
    // +-----------------------+----------+----------+----------+----------+----------+----------+
    // |         [−high, +low] |     æ    |     ɶ    |     a    |          |     ɑ    |     ɒ    |
    // +-----------------------+----------+----------+----------+----------+----------+----------+
    //
    // ////////////// Other vowel features ///////////////////
    //
    //
    long,
    nasal,
    stress,
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////// PLACE FEATURES FOR CONSONANTS  ////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // ////////////// Major articulator features ///////////////////
    //
    labial,
    coronal,
    dorsal,
    //
    // ////////////// Features for classifying the coronals ///////////////////
    //
    anterior, //0
    distributed, //0
    strident, //0
    lateral, //0
    //
    // ////////////// Features used for classifying the labials ///////////////////
    //
    // round,
    labiodental,
    //
    // ////////////// Features used for classifying the dorsals ///////////////////
    //
    // high, //0
    // low, //0
    // front, //0
    // back, //0
    //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////// LARYNGEAL FEATURES  /////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    voice,
    spread_glottis,
    constricted_glottis,
    implosive,

    pub fn mask(self: Feature) u32 {
        var res: u32 = 1;
        res <<= @intFromEnum(self);
        return res;
    }
};
//
// enum Notation {
//   place,
// }

const FeatureName = struct {
    name: [:0]const u8,
    f: Feature,
};
const f_len = @typeInfo(Feature).Enum.fields.len;
fn sortFLen(_: void, l: FeatureName, r: FeatureName) bool {
    return l.name.len > r.name.len;
}
pub const features: [f_len]FeatureName = frs: {
    var result: [f_len]FeatureName = undefined;
    var i = 0;
    while (i < f_len) {
        const f: Feature = @enumFromInt(i);
        result[i] = FeatureName{ .name = @tagName(f), .f = f };
        i += 1;
    }
    std.mem.sort(FeatureName, &result, {}, sortFLen);

    break :frs result;
};

// test "features" {
//     std.debug.print("Features: \n", .{});
//     for (features) |f| {
//         std.debug.print("\t{s}\n", .{f.name});
//     }
// }
//
